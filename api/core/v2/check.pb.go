// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: check.proto

package v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A CheckRequest represents a request to execute a check
type CheckRequest struct {
	// Config is the specification of a check.
	Config *CheckConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	// Assets are a list of assets required to execute check.
	Assets []Asset `protobuf:"bytes,2,rep,name=assets" json:"assets"`
	// Hooks are a list of hooks to be executed after a check.
	Hooks []HookConfig `protobuf:"bytes,3,rep,name=hooks" json:"hooks"`
	// Issued describes the time in which the check request was issued
	Issued               int64    `protobuf:"varint,4,opt,name=Issued,proto3" json:"issued"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckRequest) Reset()         { *m = CheckRequest{} }
func (m *CheckRequest) String() string { return proto.CompactTextString(m) }
func (*CheckRequest) ProtoMessage()    {}
func (*CheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_check_d8d3c606fb107336, []int{0}
}
func (m *CheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckRequest.Merge(dst, src)
}
func (m *CheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckRequest proto.InternalMessageInfo

func (m *CheckRequest) GetConfig() *CheckConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *CheckRequest) GetAssets() []Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *CheckRequest) GetHooks() []HookConfig {
	if m != nil {
		return m.Hooks
	}
	return nil
}

func (m *CheckRequest) GetIssued() int64 {
	if m != nil {
		return m.Issued
	}
	return 0
}

// A ProxyRequests represents a request to execute a proxy check
type ProxyRequests struct {
	// EntityAttributes store serialized arbitrary JSON-encoded data to match
	// entities in the registry.
	EntityAttributes []string `protobuf:"bytes,1,rep,name=entity_attributes,json=entityAttributes" json:"entity_attributes"`
	// Splay indicates if proxy check requests should be splayed, published
	// evenly over a window of time.
	Splay bool `protobuf:"varint,2,opt,name=splay,proto3" json:"splay"`
	// SplayCoverage is the percentage used for proxy check request splay
	// calculation.
	SplayCoverage        uint32   `protobuf:"varint,3,opt,name=splay_coverage,json=splayCoverage,proto3" json:"splay_coverage"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyRequests) Reset()         { *m = ProxyRequests{} }
func (m *ProxyRequests) String() string { return proto.CompactTextString(m) }
func (*ProxyRequests) ProtoMessage()    {}
func (*ProxyRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_check_d8d3c606fb107336, []int{1}
}
func (m *ProxyRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProxyRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyRequests.Merge(dst, src)
}
func (m *ProxyRequests) XXX_Size() int {
	return m.Size()
}
func (m *ProxyRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyRequests.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyRequests proto.InternalMessageInfo

func (m *ProxyRequests) GetEntityAttributes() []string {
	if m != nil {
		return m.EntityAttributes
	}
	return nil
}

func (m *ProxyRequests) GetSplay() bool {
	if m != nil {
		return m.Splay
	}
	return false
}

func (m *ProxyRequests) GetSplayCoverage() uint32 {
	if m != nil {
		return m.SplayCoverage
	}
	return 0
}

// CheckConfig is the specification of a check.
type CheckConfig struct {
	// Command is the command to be executed.
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Handlers are the event handler for the check (incidents and/or metrics).
	Handlers []string `protobuf:"bytes,3,rep,name=handlers" json:"handlers"`
	// HighFlapThreshold is the flap detection high threshold (% state change)
	// for the check. Sensu uses the same flap detection algorithm as Nagios.
	HighFlapThreshold uint32 `protobuf:"varint,4,opt,name=high_flap_threshold,json=highFlapThreshold,proto3" json:"high_flap_threshold"`
	// Interval is the interval, in seconds, at which the check should be run.
	Interval uint32 `protobuf:"varint,5,opt,name=interval,proto3" json:"interval"`
	// LowFlapThreshold is the flap detection low threshold (% state change) for
	// the check. Sensu uses the same flap detection algorithm as Nagios.
	LowFlapThreshold uint32 `protobuf:"varint,6,opt,name=low_flap_threshold,json=lowFlapThreshold,proto3" json:"low_flap_threshold"`
	// Publish indicates if check requests are published for the check
	Publish bool `protobuf:"varint,9,opt,name=publish,proto3" json:"publish"`
	// RuntimeAssets are a list of assets required to execute check.
	RuntimeAssets []string `protobuf:"bytes,10,rep,name=runtime_assets,json=runtimeAssets" json:"runtime_assets"`
	// Subscriptions is the list of subscribers for the check.
	Subscriptions []string `protobuf:"bytes,11,rep,name=subscriptions" json:"subscriptions"`
	// ExtendedAttributes store serialized arbitrary JSON-encoded data
	ExtendedAttributes []byte `protobuf:"bytes,12,opt,name=ExtendedAttributes,proto3" json:"-"`
	// Sources indicates the name of the entity representing an external
	// resource
	ProxyEntityName string `protobuf:"bytes,13,opt,name=proxy_entity_name,json=proxyEntityName,proto3" json:"proxy_entity_name"`
	// CheckHooks is the list of check hooks for the check
	CheckHooks []HookList `protobuf:"bytes,14,rep,name=check_hooks,json=checkHooks" json:"check_hooks"`
	// STDIN indicates if the check command accepts JSON via stdin from the
	// agent
	Stdin bool `protobuf:"varint,15,opt,name=stdin,proto3" json:"stdin"`
	// Subdue represents one or more time windows when the check should be
	// subdued.
	Subdue *TimeWindowWhen `protobuf:"bytes,16,opt,name=subdue" json:"subdue"`
	// Cron is the cron string at which the check should be run.
	Cron string `protobuf:"bytes,17,opt,name=cron,proto3" json:"cron,omitempty"`
	// TTL represents the length of time in seconds for which a check result is
	// valid.
	Ttl int64 `protobuf:"varint,18,opt,name=ttl,proto3" json:"ttl"`
	// Timeout is the timeout, in seconds, at which the check has to run
	Timeout uint32 `protobuf:"varint,19,opt,name=timeout,proto3" json:"timeout"`
	// ProxyRequests represents a request to execute a proxy check
	ProxyRequests *ProxyRequests `protobuf:"bytes,20,opt,name=proxy_requests,json=proxyRequests" json:"proxy_requests,omitempty"`
	// RoundRobin enables round-robin scheduling if set true.
	RoundRobin bool `protobuf:"varint,21,opt,name=round_robin,json=roundRobin,proto3" json:"round_robin"`
	// OutputOutputMetricFormat is the metric protocol that the check's output
	// will be expected to follow in order to be extracted.
	OutputMetricFormat string `protobuf:"bytes,22,opt,name=output_metric_format,json=outputMetricFormat,proto3" json:"output_metric_format"`
	// OutputOutputMetricHandlers is the list of event handlers that will
	// respond to metrics that have been extracted from the check.
	OutputMetricHandlers []string `protobuf:"bytes,23,rep,name=output_metric_handlers,json=outputMetricHandlers" json:"output_metric_handlers"`
	// EnvVars is the list of environment variables to set for the check's
	// execution environment.
	EnvVars []string `protobuf:"bytes,24,rep,name=env_vars,json=envVars" json:"env_vars"`
	// Metadata contains the name, namespace, labels and annotations of the
	// check
	ObjectMeta `protobuf:"bytes,26,opt,name=metadata,embedded=metadata" json:"metadata,omitempty"`
	// MaxOutputSize is the maximum size in bytes that will be stored for check
	// output. If check output is larger than MaxOutputSize, it will be
	// truncated when stored. Filters, mutators, and handlers will still have
	// access to the full check output at the time the event occurs.
	MaxOutputSize int64 `protobuf:"varint,27,opt,name=max_output_size,json=maxOutputSize,proto3" json:"max_output_size,omitempty"`
	// DiscardOutput causes agents to discard check output. No check output is
	// written to the backend, but metrics extraction is still performed.
	DiscardOutput bool `protobuf:"varint,28,opt,name=discard_output,json=discardOutput,proto3" json:"discard_output,omitempty"`
	// GroupBy is the check fields used to group events for this check.
	// Defaults to legacy Sensu behavior of grouping by check name and hostname.
	GroupBy              *CheckKey `protobuf:"bytes,29,opt,name=group_by,json=groupBy,proto3" json:"group_by"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CheckConfig) Reset()         { *m = CheckConfig{} }
func (m *CheckConfig) String() string { return proto.CompactTextString(m) }
func (*CheckConfig) ProtoMessage()    {}
func (*CheckConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_check_d8d3c606fb107336, []int{2}
}
func (m *CheckConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConfig.Merge(dst, src)
}
func (m *CheckConfig) XXX_Size() int {
	return m.Size()
}
func (m *CheckConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConfig proto.InternalMessageInfo

// A Check is a check specification and optionally the results of the check's
// execution.
type Check struct {
	// Command is the command to be executed.
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Handlers are the event handler for the check (incidents and/or metrics).
	Handlers []string `protobuf:"bytes,3,rep,name=handlers" json:"handlers"`
	// HighFlapThreshold is the flap detection high threshold (% state change)
	// for the check. Sensu uses the same flap detection algorithm as Nagios.
	HighFlapThreshold uint32 `protobuf:"varint,4,opt,name=high_flap_threshold,json=highFlapThreshold,proto3" json:"high_flap_threshold"`
	// Interval is the interval, in seconds, at which the check should be run.
	Interval uint32 `protobuf:"varint,5,opt,name=interval,proto3" json:"interval"`
	// LowFlapThreshold is the flap detection low threshold (% state change) for
	// the check. Sensu uses the same flap detection algorithm as Nagios.
	LowFlapThreshold uint32 `protobuf:"varint,6,opt,name=low_flap_threshold,json=lowFlapThreshold,proto3" json:"low_flap_threshold"`
	// Publish indicates if check requests are published for the check
	Publish bool `protobuf:"varint,9,opt,name=publish,proto3" json:"publish"`
	// RuntimeAssets are a list of assets required to execute check.
	RuntimeAssets []string `protobuf:"bytes,10,rep,name=runtime_assets,json=runtimeAssets" json:"runtime_assets"`
	// Subscriptions is the list of subscribers for the check.
	Subscriptions []string `protobuf:"bytes,11,rep,name=subscriptions" json:"subscriptions"`
	// Sources indicates the name of the entity representing an external
	// resource
	ProxyEntityName string `protobuf:"bytes,13,opt,name=proxy_entity_name,json=proxyEntityName,proto3" json:"proxy_entity_name"`
	// CheckHooks is the list of check hooks for the check
	CheckHooks []HookList `protobuf:"bytes,14,rep,name=check_hooks,json=checkHooks" json:"check_hooks"`
	// STDIN indicates if the check command accepts JSON via stdin from the
	// agent
	Stdin bool `protobuf:"varint,15,opt,name=stdin,proto3" json:"stdin"`
	// Subdue represents one or more time windows when the check should be
	// subdued.
	Subdue *TimeWindowWhen `protobuf:"bytes,16,opt,name=subdue" json:"subdue"`
	// Cron is the cron string at which the check should be run.
	Cron string `protobuf:"bytes,17,opt,name=cron,proto3" json:"cron,omitempty"`
	// TTL represents the length of time in seconds for which a check result is
	// valid.
	Ttl int64 `protobuf:"varint,18,opt,name=ttl,proto3" json:"ttl"`
	// Timeout is the timeout, in seconds, at which the check has to run
	Timeout uint32 `protobuf:"varint,19,opt,name=timeout,proto3" json:"timeout"`
	// ProxyRequests represents a request to execute a proxy check
	ProxyRequests *ProxyRequests `protobuf:"bytes,20,opt,name=proxy_requests,json=proxyRequests" json:"proxy_requests,omitempty"`
	// RoundRobin enables round-robin scheduling if set true.
	RoundRobin bool `protobuf:"varint,21,opt,name=round_robin,json=roundRobin,proto3" json:"round_robin"`
	// Duration of execution
	Duration float64 `protobuf:"fixed64,22,opt,name=duration,proto3" json:"duration,omitempty"`
	// Executed describes the time in which the check request was executed
	Executed int64 `protobuf:"varint,23,opt,name=executed,proto3" json:"executed"`
	// History is the check state history.
	History []CheckHistory `protobuf:"bytes,24,rep,name=history" json:"history"`
	// Issued describes the time in which the check request was issued
	Issued int64 `protobuf:"varint,25,opt,name=issued,proto3" json:"issued"`
	// Output from the execution of Command
	Output string `protobuf:"bytes,26,opt,name=output,proto3" json:"output"`
	// State provides handlers with more information about the state change
	State string `protobuf:"bytes,27,opt,name=state,proto3" json:"state,omitempty"`
	// Status is the exit status code produced by the check
	Status uint32 `protobuf:"varint,28,opt,name=status,proto3" json:"status"`
	// TotalStateChange indicates the total state change percentage for the
	// check's history
	TotalStateChange uint32 `protobuf:"varint,29,opt,name=total_state_change,json=totalStateChange,proto3" json:"total_state_change"`
	// LastOK displays last time this check was ok; if event status is 0 this is
	// set to timestamp
	LastOK int64 `protobuf:"varint,30,opt,name=last_ok,json=lastOk,proto3" json:"last_ok"`
	// Occurrences indicates the number of times an event has occurred for a
	// client/check pair with the same check status
	Occurrences int64 `protobuf:"varint,31,opt,name=occurrences,proto3" json:"occurrences"`
	// OccurrencesWatermark indicates the high water mark tracking number of
	// occurrences at the current severity
	OccurrencesWatermark int64 `protobuf:"varint,32,opt,name=occurrences_watermark,json=occurrencesWatermark,proto3" json:"occurrences_watermark"`
	// Silenced is a list of silenced entry ids (subscription and check name)
	Silenced []string `protobuf:"bytes,33,rep,name=silenced" json:"silenced,omitempty"`
	// Hooks describes the results of multiple hooks; if event is associated to
	// hook execution.
	Hooks []*Hook `protobuf:"bytes,34,rep,name=hooks" json:"hooks,omitempty"`
	// OutputOutputMetricFormat is the metric protocol that the check's output
	// will be expected to follow in order to be extracted.
	OutputMetricFormat string `protobuf:"bytes,35,opt,name=output_metric_format,json=outputMetricFormat,proto3" json:"output_metric_format"`
	// OutputOutputMetricHandlers is the list of event handlers that will
	// respond to metrics that have been extracted from the check.
	OutputMetricHandlers []string `protobuf:"bytes,36,rep,name=output_metric_handlers,json=outputMetricHandlers" json:"output_metric_handlers"`
	// EnvVars is the list of environment variables to set for the check's
	// execution environment.
	EnvVars []string `protobuf:"bytes,37,rep,name=env_vars,json=envVars" json:"env_vars"`
	// Metadata contains the name, namespace, labels and annotations of the
	// check
	ObjectMeta `protobuf:"bytes,38,opt,name=metadata,embedded=metadata" json:"metadata,omitempty"`
	// MaxOutputSize is the maximum size in bytes that will be stored for check
	// output. If check output is larger than MaxOutputSize, it will be
	// truncated when stored. Filters, mutators, and handlers will still have
	// access to the full check output at the time the event occurs.
	MaxOutputSize int64 `protobuf:"varint,39,opt,name=max_output_size,json=maxOutputSize,proto3" json:"max_output_size,omitempty"`
	// DiscardOutput causes agents to discard check output. No check output is
	// written to the backend, but metrics extraction is still performed.
	DiscardOutput bool `protobuf:"varint,40,opt,name=discard_output,json=discardOutput,proto3" json:"discard_output,omitempty"`
	// GroupBy is the check fields used to group events for this check.
	// Defaults to legacy Sensu behavior of grouping by check name and hostname.
	GroupBy *CheckKey `protobuf:"bytes,41,opt,name=group_by,json=groupBy,proto3" json:"group_by"`
	// ExtendedAttributes store serialized arbitrary JSON-encoded data
	ExtendedAttributes   []byte   `protobuf:"bytes,99,opt,name=ExtendedAttributes,proto3" json:"-"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Check) Reset()         { *m = Check{} }
func (m *Check) String() string { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()    {}
func (*Check) Descriptor() ([]byte, []int) {
	return fileDescriptor_check_d8d3c606fb107336, []int{3}
}
func (m *Check) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Check) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Check.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Check) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Check.Merge(dst, src)
}
func (m *Check) XXX_Size() int {
	return m.Size()
}
func (m *Check) XXX_DiscardUnknown() {
	xxx_messageInfo_Check.DiscardUnknown(m)
}

var xxx_messageInfo_Check proto.InternalMessageInfo

// CheckHistory is a record of a check execution and its status
type CheckHistory struct {
	// Status is the exit status code produced by the check.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status"`
	// Executed describes the time in which the check request was executed
	Executed             int64    `protobuf:"varint,2,opt,name=executed,proto3" json:"executed"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckHistory) Reset()         { *m = CheckHistory{} }
func (m *CheckHistory) String() string { return proto.CompactTextString(m) }
func (*CheckHistory) ProtoMessage()    {}
func (*CheckHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_check_d8d3c606fb107336, []int{4}
}
func (m *CheckHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckHistory.Merge(dst, src)
}
func (m *CheckHistory) XXX_Size() int {
	return m.Size()
}
func (m *CheckHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckHistory.DiscardUnknown(m)
}

var xxx_messageInfo_CheckHistory proto.InternalMessageInfo

func (m *CheckHistory) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CheckHistory) GetExecuted() int64 {
	if m != nil {
		return m.Executed
	}
	return 0
}

// CheckKey is a set of attributes and labels that are used to group events for a given check.
// The uniqueness of all of these attributes combined is what makes up the grouping key.
type CheckKey struct {
	// Name sets whether to group by check name.
	Name bool `protobuf:"varint,1,opt,name=name,proto3" json:"name"`
	// Hostname sets whether to group by hostname.
	Hostname bool `protobuf:"varint,2,opt,name=hostname,proto3" json:"hostname"`
	// Check labels to group by.
	CheckLabels []string `protobuf:"bytes,3,rep,name=check_labels,json=checkLabels,proto3" json:"check_labels"`
	// Entity labels to group by.
	EntityLabels []string `protobuf:"bytes,4,rep,name=entity_labels,json=entityLabels,proto3" json:"entity_labels"`
	// Event labels to group by.
	EventLabels          []string `protobuf:"bytes,5,rep,name=event_labels,json=eventLabels,proto3" json:"event_labels"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckKey) Reset()         { *m = CheckKey{} }
func (m *CheckKey) String() string { return proto.CompactTextString(m) }
func (*CheckKey) ProtoMessage()    {}
func (*CheckKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_check_d8d3c606fb107336, []int{5}
}
func (m *CheckKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckKey.Merge(m, src)
}
func (m *CheckKey) XXX_Size() int {
	return m.Size()
}
func (m *CheckKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckKey.DiscardUnknown(m)
}

var xxx_messageInfo_CheckKey proto.InternalMessageInfo

func (m *CheckKey) GetName() bool {
	if m != nil {
		return m.Name
	}
	return false
}

func (m *CheckKey) GetHostname() bool {
	if m != nil {
		return m.Hostname
	}
	return false
}

func (m *CheckKey) GetCheckLabels() []string {
	if m != nil {
		return m.CheckLabels
	}
	return nil
}

func (m *CheckKey) GetEntityLabels() []string {
	if m != nil {
		return m.EntityLabels
	}
	return nil
}

func (m *CheckKey) GetEventLabels() []string {
	if m != nil {
		return m.EventLabels
	}
	return nil
}

func init() {
	proto.RegisterType((*CheckRequest)(nil), "sensu.core.v2.CheckRequest")
	proto.RegisterType((*ProxyRequests)(nil), "sensu.core.v2.ProxyRequests")
	proto.RegisterType((*CheckConfig)(nil), "sensu.core.v2.CheckConfig")
	proto.RegisterType((*Check)(nil), "sensu.core.v2.Check")
	proto.RegisterType((*CheckHistory)(nil), "sensu.core.v2.CheckHistory")
	proto.RegisterType((*CheckKey)(nil), "sensu.core.v2.CheckKey")
}

func init() { proto.RegisterFile("check.proto", fileDescriptor_check_d8d3c606fb107336) }

var fileDescriptor_check_d8d3c606fb107336 = []byte{
	// 1445 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6f, 0x1b, 0xb7,
	0x12, 0xcf, 0xfa, 0x43, 0x96, 0x29, 0xcb, 0x1f, 0xb4, 0x1d, 0xd3, 0x8e, 0xa3, 0xd5, 0xf3, 0x7b,
	0x49, 0xf4, 0x80, 0x17, 0xe7, 0xd5, 0x41, 0xfa, 0x75, 0xaa, 0xe5, 0x26, 0x75, 0x9b, 0x0f, 0x07,
	0x4c, 0xda, 0x00, 0x45, 0x81, 0x05, 0xb5, 0xa2, 0xa5, 0xad, 0xa5, 0xa5, 0xba, 0xe4, 0xca, 0x56,
	0xfe, 0x82, 0xfe, 0x19, 0x39, 0xe6, 0xd6, 0x6b, 0xaf, 0xbd, 0xe5, 0x98, 0x5b, 0x6f, 0x8b, 0xd6,
	0xc7, 0xed, 0xb5, 0x87, 0x1e, 0x0b, 0x0e, 0xb9, 0xb2, 0x64, 0xcb, 0x4d, 0x50, 0xa4, 0x40, 0x51,
	0xe4, 0xe2, 0x9d, 0xf9, 0xcd, 0x8c, 0xc8, 0x1d, 0xce, 0xfc, 0x86, 0x6b, 0x54, 0xf0, 0x9b, 0xdc,
	0x3f, 0xd8, 0xec, 0x44, 0x42, 0x09, 0x5c, 0x94, 0x3c, 0x94, 0xf1, 0xa6, 0x2f, 0x22, 0xbe, 0xd9,
	0xdd, 0x5a, 0xbb, 0xde, 0x08, 0x54, 0x33, 0xae, 0x6d, 0xfa, 0xa2, 0x7d, 0xa3, 0x21, 0x1a, 0xe2,
	0x06, 0x78, 0xd5, 0xe2, 0x7d, 0xd0, 0x40, 0x01, 0xc9, 0x44, 0xaf, 0x15, 0x98, 0x94, 0x5c, 0x59,
	0x05, 0x35, 0x85, 0x38, 0xc8, 0xe4, 0x36, 0x57, 0xcc, 0xca, 0x0b, 0x2a, 0x68, 0x73, 0xef, 0x30,
	0x08, 0xeb, 0xe2, 0xd0, 0x40, 0x1b, 0x3f, 0x3a, 0x68, 0x66, 0x47, 0xef, 0x82, 0xf2, 0x6f, 0x62,
	0x2e, 0x15, 0x7e, 0x1f, 0xe5, 0x7c, 0x11, 0xee, 0x07, 0x0d, 0xe2, 0x94, 0x9d, 0x4a, 0x61, 0x6b,
	0x6d, 0x73, 0x68, 0x5f, 0x9b, 0xe0, 0xbc, 0x03, 0x1e, 0xd5, 0x89, 0x17, 0x89, 0xeb, 0x50, 0xeb,
	0x8f, 0xb7, 0x50, 0x0e, 0x36, 0x21, 0xc9, 0x58, 0x79, 0xbc, 0x52, 0xd8, 0x5a, 0x3a, 0x15, 0xb9,
	0xad, 0x8d, 0x10, 0x73, 0x81, 0x5a, 0x4f, 0x7c, 0x0b, 0x4d, 0xea, 0xbd, 0x4a, 0x32, 0x0e, 0x21,
	0xab, 0xa7, 0x42, 0x76, 0x85, 0x18, 0x5c, 0xeb, 0x02, 0x35, 0xde, 0x78, 0x03, 0xe5, 0x3e, 0x95,
	0x32, 0xe6, 0x75, 0x32, 0x51, 0x76, 0x2a, 0xe3, 0x55, 0x94, 0x26, 0x6e, 0x2e, 0x00, 0x84, 0xda,
	0xe7, 0xc6, 0x77, 0x0e, 0x2a, 0x3e, 0x8c, 0xc4, 0x51, 0xcf, 0xbe, 0x99, 0xc4, 0x55, 0xb4, 0xc0,
	0x43, 0x15, 0xa8, 0x9e, 0xc7, 0x94, 0x8a, 0x82, 0x5a, 0xac, 0xb8, 0x24, 0x4e, 0x79, 0xbc, 0x32,
	0x5d, 0x5d, 0x4e, 0x13, 0xf7, 0xac, 0x91, 0xce, 0x1b, 0x68, 0xbb, 0x8f, 0x60, 0x17, 0x4d, 0xca,
	0x4e, 0x8b, 0xf5, 0xc8, 0x58, 0xd9, 0xa9, 0xe4, 0xab, 0xd3, 0x69, 0xe2, 0x1a, 0x80, 0x9a, 0x07,
	0xfe, 0x00, 0xcd, 0x82, 0xe0, 0xf9, 0xa2, 0xcb, 0x23, 0xd6, 0xe0, 0x64, 0xbc, 0xec, 0x54, 0x8a,
	0x55, 0x9c, 0x26, 0xee, 0x29, 0x0b, 0x2d, 0x82, 0xbe, 0x63, 0xd5, 0x8d, 0x5f, 0x10, 0x2a, 0x0c,
	0xa4, 0x17, 0x13, 0x34, 0xe5, 0x8b, 0x76, 0x9b, 0x85, 0x75, 0x38, 0x8b, 0x69, 0x9a, 0xa9, 0xb8,
	0x82, 0xf2, 0x4d, 0x16, 0xd6, 0x5b, 0x3c, 0x32, 0x99, 0x9b, 0xae, 0xce, 0xa4, 0x89, 0xdb, 0xc7,
	0x68, 0x5f, 0xc2, 0x9f, 0xa0, 0xc5, 0x66, 0xd0, 0x68, 0x7a, 0xfb, 0x2d, 0xd6, 0xf1, 0x54, 0x33,
	0xe2, 0xb2, 0x29, 0x5a, 0x26, 0x6d, 0xc5, 0xea, 0x4a, 0x9a, 0xb8, 0xa3, 0xcc, 0x74, 0x41, 0x83,
	0x77, 0x5a, 0xac, 0xf3, 0x38, 0x83, 0xf4, 0x92, 0x41, 0xa8, 0x78, 0xd4, 0x65, 0x2d, 0x32, 0x09,
	0xd1, 0xb0, 0x64, 0x86, 0xd1, 0xbe, 0x84, 0x3f, 0x46, 0xb8, 0x25, 0x0e, 0x4f, 0xaf, 0x98, 0x83,
	0x98, 0x8b, 0x69, 0xe2, 0x8e, 0xb0, 0xd2, 0xf9, 0x96, 0x38, 0x1c, 0x5e, 0xef, 0x0a, 0x9a, 0xea,
	0xc4, 0xb5, 0x56, 0x20, 0x9b, 0x64, 0x1a, 0x52, 0x5d, 0x48, 0x13, 0x37, 0x83, 0x68, 0x26, 0xe8,
	0x74, 0x47, 0x71, 0x08, 0x75, 0x6d, 0x8b, 0x0f, 0x41, 0x3e, 0x20, 0xdd, 0xc3, 0x16, 0x5a, 0xb4,
	0xfa, 0xb6, 0xa9, 0xbd, 0xf7, 0x50, 0x51, 0xc6, 0x35, 0xe9, 0x47, 0x41, 0x47, 0x05, 0x22, 0x94,
	0xa4, 0x00, 0x91, 0x0b, 0x69, 0xe2, 0x0e, 0x1b, 0xe8, 0xb0, 0x8a, 0x6f, 0x21, 0x7c, 0xfb, 0x48,
	0xf1, 0xb0, 0xce, 0xeb, 0x27, 0x95, 0x41, 0x66, 0xca, 0x4e, 0x65, 0xa6, 0x3a, 0x99, 0x26, 0xae,
	0x73, 0x9d, 0x62, 0x7e, 0xc6, 0x01, 0x3f, 0x46, 0x0b, 0x1d, 0x5d, 0x8f, 0x9e, 0xad, 0xb3, 0x90,
	0xb5, 0x39, 0x29, 0xea, 0x83, 0xad, 0x56, 0x8e, 0x13, 0x77, 0x0e, 0x8a, 0xf5, 0x36, 0xd8, 0x1e,
	0xb0, 0x36, 0xd7, 0x15, 0x79, 0xc6, 0x9f, 0xce, 0x75, 0x86, 0xbd, 0xf0, 0x7d, 0xcb, 0x22, 0x9e,
	0xe9, 0xa3, 0x59, 0xe8, 0xa3, 0x95, 0x11, 0x7d, 0x74, 0x2f, 0x90, 0xaa, 0xba, 0xa8, 0xbb, 0x28,
	0x4d, 0xdc, 0xc1, 0x18, 0x8a, 0x40, 0xd9, 0x85, 0xce, 0xd2, 0xf5, 0xad, 0xea, 0x41, 0x48, 0xe6,
	0x06, 0xea, 0x5b, 0x03, 0xd4, 0x3c, 0xf0, 0x36, 0xca, 0xc9, 0xb8, 0x56, 0x8f, 0x39, 0x99, 0x07,
	0x7e, 0xb8, 0x7c, 0x6a, 0xa9, 0xc7, 0x41, 0x9b, 0x3f, 0x01, 0x86, 0x79, 0xd2, 0xe4, 0xa1, 0xe9,
	0x4c, 0x13, 0x40, 0xed, 0x13, 0x63, 0x34, 0xe1, 0x47, 0x22, 0x24, 0x0b, 0x50, 0xd4, 0x20, 0xe3,
	0x55, 0x34, 0xae, 0x54, 0x8b, 0x60, 0x68, 0xe7, 0xa9, 0x34, 0x71, 0xb5, 0x4a, 0xf5, 0x1f, 0x5d,
	0x09, 0xfa, 0xd4, 0x44, 0xac, 0xc8, 0x22, 0x14, 0x11, 0x54, 0x82, 0x85, 0x68, 0x26, 0xe0, 0x1d,
	0x34, 0x6b, 0xd2, 0x15, 0xd9, 0x7e, 0x27, 0x4b, 0xb0, 0xc1, 0xf5, 0x53, 0x1b, 0x1c, 0xe2, 0x04,
	0x5a, 0xec, 0x0c, 0x51, 0xc4, 0xff, 0x51, 0x21, 0x12, 0x71, 0x58, 0xf7, 0x22, 0x51, 0x0b, 0x42,
	0xb2, 0x0c, 0x49, 0x98, 0xd3, 0x09, 0x1b, 0x80, 0x29, 0x02, 0x85, 0x6a, 0x19, 0x7f, 0x86, 0x96,
	0x44, 0xac, 0x3a, 0xb1, 0xf2, 0xda, 0x5c, 0x45, 0x81, 0xef, 0xed, 0x8b, 0xa8, 0xcd, 0x14, 0xb9,
	0x08, 0x07, 0x4b, 0xd2, 0xc4, 0x1d, 0x69, 0xa7, 0xd8, 0xa0, 0xf7, 0x01, 0xbc, 0x03, 0x18, 0x7e,
	0x88, 0x2e, 0x0e, 0xfb, 0xf6, 0x9b, 0x7c, 0x05, 0x4a, 0x73, 0x2d, 0x4d, 0xdc, 0x73, 0x3c, 0xe8,
	0xd2, 0xe0, 0xef, 0xed, 0x66, 0xed, 0x7f, 0x0d, 0xe5, 0x79, 0xd8, 0xf5, 0xba, 0x2c, 0x92, 0x84,
	0x9c, 0x10, 0x45, 0x86, 0xd1, 0x29, 0x1e, 0x76, 0xbf, 0x60, 0x91, 0xc4, 0x9f, 0xa3, 0xbc, 0x1e,
	0x14, 0x75, 0xa6, 0x18, 0x59, 0x83, 0xbc, 0x9d, 0xe6, 0xe2, 0xbd, 0xda, 0xd7, 0xdc, 0xd7, 0xbf,
	0xcf, 0xaa, 0x25, 0x5d, 0x45, 0x2f, 0x13, 0xd7, 0xd1, 0xdd, 0x9c, 0x85, 0xfd, 0x4f, 0xb4, 0x03,
	0xc5, 0xdb, 0x1d, 0xd5, 0xa3, 0xfd, 0x9f, 0xc2, 0x57, 0xd1, 0x5c, 0x9b, 0x1d, 0x79, 0x76, 0xcf,
	0x32, 0x78, 0xca, 0xc9, 0x25, 0x7d, 0xc4, 0xb4, 0xd8, 0x66, 0x47, 0x7b, 0x80, 0x3e, 0x0a, 0x9e,
	0x72, 0x7c, 0x05, 0xcd, 0xd6, 0x03, 0xe9, 0xb3, 0xa8, 0x6e, 0x7d, 0xc9, 0xba, 0x4e, 0x3d, 0x2d,
	0x5a, 0xd4, 0xb8, 0xe2, 0x8f, 0x50, 0xbe, 0x11, 0x89, 0xb8, 0xe3, 0xd5, 0x7a, 0xe4, 0x32, 0xec,
	0x72, 0x65, 0xd4, 0x78, 0xba, 0xcb, 0x7b, 0xe6, 0x3d, 0x33, 0x67, 0x3a, 0x05, 0x52, 0xb5, 0xf7,
	0x61, 0xfe, 0xdb, 0x67, 0xee, 0x85, 0xe7, 0xcf, 0x5c, 0x67, 0xe3, 0x87, 0x39, 0x34, 0x09, 0xde,
	0x6f, 0x79, 0xf6, 0x6f, 0xca, 0xb3, 0x6f, 0x09, 0xf3, 0x9f, 0x48, 0x98, 0x6b, 0x28, 0x5f, 0x8f,
	0x23, 0xa6, 0x8f, 0x18, 0x48, 0xd2, 0xa1, 0x7d, 0x5d, 0x17, 0x3f, 0x3f, 0xe2, 0x7e, 0xac, 0x78,
	0x9d, 0xac, 0xc0, 0x9b, 0x19, 0xba, 0xb2, 0x18, 0xed, 0x4b, 0xf8, 0x0e, 0x9a, 0x6a, 0x06, 0x52,
	0x89, 0xa8, 0x07, 0xbc, 0x56, 0xd8, 0xba, 0x34, 0x8a, 0x08, 0x76, 0x8d, 0x4b, 0x75, 0xce, 0x9e,
	0x62, 0x16, 0x43, 0x33, 0x41, 0xdf, 0x24, 0xcd, 0x7d, 0x91, 0xac, 0x9e, 0x77, 0x93, 0xd4, 0x3e,
	0x96, 0x94, 0xd6, 0xa0, 0xf8, 0xc0, 0xc7, 0x20, 0xd4, 0x3e, 0xf1, 0x92, 0x2e, 0x03, 0xa6, 0x0c,
	0xbd, 0x4d, 0x53, 0xa3, 0xe8, 0x48, 0x2d, 0xc4, 0x12, 0xe8, 0xac, 0x68, 0x0f, 0x17, 0x10, 0x6a,
	0x9f, 0xba, 0x8d, 0x95, 0x50, 0xac, 0xe5, 0x41, 0x88, 0xe7, 0x37, 0x59, 0xd8, 0xe0, 0xc0, 0x6e,
	0xb6, 0x8d, 0xcf, 0x5a, 0xe9, 0x3c, 0x60, 0x8f, 0x34, 0xb4, 0x03, 0x08, 0xde, 0x44, 0x53, 0x2d,
	0x26, 0x95, 0x27, 0x0e, 0x48, 0x09, 0x5e, 0x64, 0xf9, 0x38, 0x71, 0x73, 0xf7, 0x98, 0x54, 0x7b,
	0x77, 0xf5, 0x8b, 0x5b, 0x23, 0xcd, 0x69, 0x61, 0xef, 0x00, 0xbf, 0x83, 0x0a, 0xc2, 0xf7, 0xe3,
	0x28, 0xe2, 0xa1, 0xcf, 0x25, 0x71, 0x21, 0x06, 0xce, 0x6d, 0x00, 0xa6, 0x83, 0x0a, 0x7e, 0x80,
	0x96, 0x07, 0x54, 0xef, 0x90, 0x29, 0x1e, 0xb5, 0x59, 0x74, 0x40, 0xca, 0x10, 0xbc, 0x9a, 0x26,
	0xee, 0x68, 0x07, 0xba, 0x34, 0x00, 0x3f, 0xc9, 0x50, 0x5c, 0x46, 0x79, 0x19, 0xb4, 0x34, 0x58,
	0x27, 0xff, 0x02, 0x4a, 0x30, 0xdf, 0x13, 0x7d, 0x14, 0xdf, 0xc8, 0xbe, 0x0e, 0x36, 0xe0, 0x88,
	0x17, 0x47, 0x34, 0xa9, 0x8d, 0xb1, 0xdf, 0x05, 0xe7, 0x0d, 0xe3, 0x7f, 0xbf, 0xd1, 0x61, 0xfc,
	0x9f, 0x37, 0x30, 0x8c, 0xaf, 0xbc, 0xee, 0x30, 0xbe, 0xfa, 0x97, 0x0e, 0xe3, 0x6b, 0xaf, 0x37,
	0x8c, 0x2b, 0xaf, 0x1a, 0xc6, 0xff, 0xfd, 0x33, 0xc3, 0xf8, 0x9c, 0x8b, 0xb4, 0xff, 0x8a, 0x8b,
	0xf4, 0xc0, 0x0c, 0xff, 0xca, 0x7e, 0xbc, 0xee, 0x9e, 0x74, 0xb3, 0xed, 0x37, 0xe7, 0xdc, 0x7e,
	0x1b, 0xe4, 0x98, 0xb1, 0x3f, 0xe2, 0x98, 0x8d, 0x5f, 0x1d, 0x94, 0xcf, 0x5e, 0x01, 0xaf, 0xa3,
	0x09, 0x98, 0x3f, 0x0e, 0x30, 0x5c, 0x3e, 0x4d, 0x5c, 0xd0, 0x29, 0xfc, 0x85, 0x8b, 0x82, 0x90,
	0x0a, 0x3c, 0xcc, 0x97, 0xa1, 0xb9, 0x28, 0x58, 0x8c, 0xf6, 0x25, 0x7c, 0x13, 0xcd, 0x98, 0x51,
	0xd2, 0x62, 0x35, 0xde, 0xca, 0xae, 0x15, 0xf3, 0x69, 0xe2, 0x0e, 0xe1, 0xd4, 0x0c, 0x9c, 0x7b,
	0xa0, 0xe0, 0x77, 0x51, 0xd1, 0xce, 0x34, 0x1b, 0x35, 0x71, 0x32, 0x42, 0x87, 0x0c, 0x74, 0xc6,
	0xa8, 0x36, 0xee, 0x26, 0x9a, 0xe1, 0x5d, 0x1e, 0xaa, 0x2c, 0x6c, 0xf2, 0x64, 0xb1, 0x41, 0x9c,
	0x16, 0x40, 0x33, 0x41, 0xd5, 0xf5, 0xdf, 0x7e, 0x2e, 0x39, 0xcf, 0x8f, 0x4b, 0xce, 0xf7, 0xc7,
	0x25, 0xe7, 0xc5, 0x71, 0xc9, 0x79, 0x79, 0x5c, 0x72, 0x7e, 0x3a, 0x2e, 0x39, 0x5f, 0x8e, 0x75,
	0xb7, 0x6a, 0x39, 0xf8, 0xbf, 0xc1, 0xcd, 0xdf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x26, 0x70,
	0x85, 0xbc, 0x10, 0x00, 0x00,
}

func (this *CheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest)
	if !ok {
		that2, ok := that.(CheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(&that1.Assets[i]) {
			return false
		}
	}
	if len(this.Hooks) != len(that1.Hooks) {
		return false
	}
	for i := range this.Hooks {
		if !this.Hooks[i].Equal(&that1.Hooks[i]) {
			return false
		}
	}
	if this.Issued != that1.Issued {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ProxyRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyRequests)
	if !ok {
		that2, ok := that.(ProxyRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EntityAttributes) != len(that1.EntityAttributes) {
		return false
	}
	for i := range this.EntityAttributes {
		if this.EntityAttributes[i] != that1.EntityAttributes[i] {
			return false
		}
	}
	if this.Splay != that1.Splay {
		return false
	}
	if this.SplayCoverage != that1.SplayCoverage {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CheckConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConfig)
	if !ok {
		that2, ok := that.(CheckConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Command != that1.Command {
		return false
	}
	if len(this.Handlers) != len(that1.Handlers) {
		return false
	}
	for i := range this.Handlers {
		if this.Handlers[i] != that1.Handlers[i] {
			return false
		}
	}
	if this.HighFlapThreshold != that1.HighFlapThreshold {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.LowFlapThreshold != that1.LowFlapThreshold {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	if len(this.RuntimeAssets) != len(that1.RuntimeAssets) {
		return false
	}
	for i := range this.RuntimeAssets {
		if this.RuntimeAssets[i] != that1.RuntimeAssets[i] {
			return false
		}
	}
	if len(this.Subscriptions) != len(that1.Subscriptions) {
		return false
	}
	for i := range this.Subscriptions {
		if this.Subscriptions[i] != that1.Subscriptions[i] {
			return false
		}
	}
	if !bytes.Equal(this.ExtendedAttributes, that1.ExtendedAttributes) {
		return false
	}
	if this.ProxyEntityName != that1.ProxyEntityName {
		return false
	}
	if len(this.CheckHooks) != len(that1.CheckHooks) {
		return false
	}
	for i := range this.CheckHooks {
		if !this.CheckHooks[i].Equal(&that1.CheckHooks[i]) {
			return false
		}
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if !this.Subdue.Equal(that1.Subdue) {
		return false
	}
	if this.Cron != that1.Cron {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ProxyRequests.Equal(that1.ProxyRequests) {
		return false
	}
	if this.RoundRobin != that1.RoundRobin {
		return false
	}
	if this.OutputMetricFormat != that1.OutputMetricFormat {
		return false
	}
	if len(this.OutputMetricHandlers) != len(that1.OutputMetricHandlers) {
		return false
	}
	for i := range this.OutputMetricHandlers {
		if this.OutputMetricHandlers[i] != that1.OutputMetricHandlers[i] {
			return false
		}
	}
	if len(this.EnvVars) != len(that1.EnvVars) {
		return false
	}
	for i := range this.EnvVars {
		if this.EnvVars[i] != that1.EnvVars[i] {
			return false
		}
	}
	if !this.ObjectMeta.Equal(&that1.ObjectMeta) {
		return false
	}
	if this.MaxOutputSize != that1.MaxOutputSize {
		return false
	}
	if this.DiscardOutput != that1.DiscardOutput {
		return false
	}
	if !this.GroupBy.Equal(that1.GroupBy) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Check) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Check)
	if !ok {
		that2, ok := that.(Check)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Command != that1.Command {
		return false
	}
	if len(this.Handlers) != len(that1.Handlers) {
		return false
	}
	for i := range this.Handlers {
		if this.Handlers[i] != that1.Handlers[i] {
			return false
		}
	}
	if this.HighFlapThreshold != that1.HighFlapThreshold {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.LowFlapThreshold != that1.LowFlapThreshold {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	if len(this.RuntimeAssets) != len(that1.RuntimeAssets) {
		return false
	}
	for i := range this.RuntimeAssets {
		if this.RuntimeAssets[i] != that1.RuntimeAssets[i] {
			return false
		}
	}
	if len(this.Subscriptions) != len(that1.Subscriptions) {
		return false
	}
	for i := range this.Subscriptions {
		if this.Subscriptions[i] != that1.Subscriptions[i] {
			return false
		}
	}
	if this.ProxyEntityName != that1.ProxyEntityName {
		return false
	}
	if len(this.CheckHooks) != len(that1.CheckHooks) {
		return false
	}
	for i := range this.CheckHooks {
		if !this.CheckHooks[i].Equal(&that1.CheckHooks[i]) {
			return false
		}
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if !this.Subdue.Equal(that1.Subdue) {
		return false
	}
	if this.Cron != that1.Cron {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ProxyRequests.Equal(that1.ProxyRequests) {
		return false
	}
	if this.RoundRobin != that1.RoundRobin {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if len(this.History) != len(that1.History) {
		return false
	}
	for i := range this.History {
		if !this.History[i].Equal(&that1.History[i]) {
			return false
		}
	}
	if this.Issued != that1.Issued {
		return false
	}
	if this.Output != that1.Output {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.TotalStateChange != that1.TotalStateChange {
		return false
	}
	if this.LastOK != that1.LastOK {
		return false
	}
	if this.Occurrences != that1.Occurrences {
		return false
	}
	if this.OccurrencesWatermark != that1.OccurrencesWatermark {
		return false
	}
	if len(this.Silenced) != len(that1.Silenced) {
		return false
	}
	for i := range this.Silenced {
		if this.Silenced[i] != that1.Silenced[i] {
			return false
		}
	}
	if len(this.Hooks) != len(that1.Hooks) {
		return false
	}
	for i := range this.Hooks {
		if !this.Hooks[i].Equal(that1.Hooks[i]) {
			return false
		}
	}
	if this.OutputMetricFormat != that1.OutputMetricFormat {
		return false
	}
	if len(this.OutputMetricHandlers) != len(that1.OutputMetricHandlers) {
		return false
	}
	for i := range this.OutputMetricHandlers {
		if this.OutputMetricHandlers[i] != that1.OutputMetricHandlers[i] {
			return false
		}
	}
	if len(this.EnvVars) != len(that1.EnvVars) {
		return false
	}
	for i := range this.EnvVars {
		if this.EnvVars[i] != that1.EnvVars[i] {
			return false
		}
	}
	if !this.ObjectMeta.Equal(&that1.ObjectMeta) {
		return false
	}
	if this.MaxOutputSize != that1.MaxOutputSize {
		return false
	}
	if this.DiscardOutput != that1.DiscardOutput {
		return false
	}
	if !this.GroupBy.Equal(that1.GroupBy) {
		return false
	}
	if !bytes.Equal(this.ExtendedAttributes, that1.ExtendedAttributes) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CheckHistory) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckHistory)
	if !ok {
		that2, ok := that.(CheckHistory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CheckKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckKey)
	if !ok {
		that2, ok := that.(CheckKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.CheckLabels) != len(that1.CheckLabels) {
		return false
	}
	for i := range this.CheckLabels {
		if this.CheckLabels[i] != that1.CheckLabels[i] {
			return false
		}
	}
	if len(this.EntityLabels) != len(that1.EntityLabels) {
		return false
	}
	for i := range this.EntityLabels {
		if this.EntityLabels[i] != that1.EntityLabels[i] {
			return false
		}
	}
	if len(this.EventLabels) != len(that1.EventLabels) {
		return false
	}
	for i := range this.EventLabels {
		if this.EventLabels[i] != that1.EventLabels[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

type CheckConfigFace interface {
	Proto() github_com_golang_protobuf_proto.Message
	GetCommand() string
	GetHandlers() []string
	GetHighFlapThreshold() uint32
	GetInterval() uint32
	GetLowFlapThreshold() uint32
	GetPublish() bool
	GetRuntimeAssets() []string
	GetSubscriptions() []string
	GetExtendedAttributes() []byte
	GetProxyEntityName() string
	GetCheckHooks() []HookList
	GetStdin() bool
	GetSubdue() *TimeWindowWhen
	GetCron() string
	GetTtl() int64
	GetTimeout() uint32
	GetProxyRequests() *ProxyRequests
	GetRoundRobin() bool
	GetOutputMetricFormat() string
	GetOutputMetricHandlers() []string
	GetEnvVars() []string
	GetObjectMeta() ObjectMeta
	GetMaxOutputSize() int64
	GetDiscardOutput() bool
	GetGroupBy() *CheckKey
}

func (this *CheckConfig) Proto() github_com_golang_protobuf_proto.Message {
	return this
}

func (this *CheckConfig) TestProto() github_com_golang_protobuf_proto.Message {
	return NewCheckConfigFromFace(this)
}

func (this *CheckConfig) GetCommand() string {
	return this.Command
}

func (this *CheckConfig) GetHandlers() []string {
	return this.Handlers
}

func (this *CheckConfig) GetHighFlapThreshold() uint32 {
	return this.HighFlapThreshold
}

func (this *CheckConfig) GetInterval() uint32 {
	return this.Interval
}

func (this *CheckConfig) GetLowFlapThreshold() uint32 {
	return this.LowFlapThreshold
}

func (this *CheckConfig) GetPublish() bool {
	return this.Publish
}

func (this *CheckConfig) GetRuntimeAssets() []string {
	return this.RuntimeAssets
}

func (this *CheckConfig) GetSubscriptions() []string {
	return this.Subscriptions
}

func (this *CheckConfig) GetExtendedAttributes() []byte {
	return this.ExtendedAttributes
}

func (this *CheckConfig) GetProxyEntityName() string {
	return this.ProxyEntityName
}

func (this *CheckConfig) GetCheckHooks() []HookList {
	return this.CheckHooks
}

func (this *CheckConfig) GetStdin() bool {
	return this.Stdin
}

func (this *CheckConfig) GetSubdue() *TimeWindowWhen {
	return this.Subdue
}

func (this *CheckConfig) GetCron() string {
	return this.Cron
}

func (this *CheckConfig) GetTtl() int64 {
	return this.Ttl
}

func (this *CheckConfig) GetTimeout() uint32 {
	return this.Timeout
}

func (this *CheckConfig) GetProxyRequests() *ProxyRequests {
	return this.ProxyRequests
}

func (this *CheckConfig) GetRoundRobin() bool {
	return this.RoundRobin
}

func (this *CheckConfig) GetOutputMetricFormat() string {
	return this.OutputMetricFormat
}

func (this *CheckConfig) GetOutputMetricHandlers() []string {
	return this.OutputMetricHandlers
}

func (this *CheckConfig) GetEnvVars() []string {
	return this.EnvVars
}

func (this *CheckConfig) GetObjectMeta() ObjectMeta {
	return this.ObjectMeta
}

func (this *CheckConfig) GetMaxOutputSize() int64 {
	return this.MaxOutputSize
}

func (this *CheckConfig) GetDiscardOutput() bool {
	return this.DiscardOutput
}

func (this *CheckConfig) GetGroupBy() *CheckKey {
	return this.GroupBy
}

func NewCheckConfigFromFace(that CheckConfigFace) *CheckConfig {
	this := &CheckConfig{}
	this.Command = that.GetCommand()
	this.Handlers = that.GetHandlers()
	this.HighFlapThreshold = that.GetHighFlapThreshold()
	this.Interval = that.GetInterval()
	this.LowFlapThreshold = that.GetLowFlapThreshold()
	this.Publish = that.GetPublish()
	this.RuntimeAssets = that.GetRuntimeAssets()
	this.Subscriptions = that.GetSubscriptions()
	this.ExtendedAttributes = that.GetExtendedAttributes()
	this.ProxyEntityName = that.GetProxyEntityName()
	this.CheckHooks = that.GetCheckHooks()
	this.Stdin = that.GetStdin()
	this.Subdue = that.GetSubdue()
	this.Cron = that.GetCron()
	this.Ttl = that.GetTtl()
	this.Timeout = that.GetTimeout()
	this.ProxyRequests = that.GetProxyRequests()
	this.RoundRobin = that.GetRoundRobin()
	this.OutputMetricFormat = that.GetOutputMetricFormat()
	this.OutputMetricHandlers = that.GetOutputMetricHandlers()
	this.EnvVars = that.GetEnvVars()
	this.ObjectMeta = that.GetObjectMeta()
	this.MaxOutputSize = that.GetMaxOutputSize()
	this.DiscardOutput = that.GetDiscardOutput()
	this.GroupBy = that.GetGroupBy()
	return this
}

type CheckFace interface {
	Proto() github_com_golang_protobuf_proto.Message
	GetCommand() string
	GetHandlers() []string
	GetHighFlapThreshold() uint32
	GetInterval() uint32
	GetLowFlapThreshold() uint32
	GetPublish() bool
	GetRuntimeAssets() []string
	GetSubscriptions() []string
	GetProxyEntityName() string
	GetCheckHooks() []HookList
	GetStdin() bool
	GetSubdue() *TimeWindowWhen
	GetCron() string
	GetTtl() int64
	GetTimeout() uint32
	GetProxyRequests() *ProxyRequests
	GetRoundRobin() bool
	GetDuration() float64
	GetExecuted() int64
	GetHistory() []CheckHistory
	GetIssued() int64
	GetOutput() string
	GetState() string
	GetStatus() uint32
	GetTotalStateChange() uint32
	GetLastOK() int64
	GetOccurrences() int64
	GetOccurrencesWatermark() int64
	GetSilenced() []string
	GetHooks() []*Hook
	GetOutputMetricFormat() string
	GetOutputMetricHandlers() []string
	GetEnvVars() []string
	GetObjectMeta() ObjectMeta
	GetMaxOutputSize() int64
	GetDiscardOutput() bool
	GetGroupBy() *CheckKey
	GetExtendedAttributes() []byte
}

func (this *Check) Proto() github_com_golang_protobuf_proto.Message {
	return this
}

func (this *Check) TestProto() github_com_golang_protobuf_proto.Message {
	return NewCheckFromFace(this)
}

func (this *Check) GetCommand() string {
	return this.Command
}

func (this *Check) GetHandlers() []string {
	return this.Handlers
}

func (this *Check) GetHighFlapThreshold() uint32 {
	return this.HighFlapThreshold
}

func (this *Check) GetInterval() uint32 {
	return this.Interval
}

func (this *Check) GetLowFlapThreshold() uint32 {
	return this.LowFlapThreshold
}

func (this *Check) GetPublish() bool {
	return this.Publish
}

func (this *Check) GetRuntimeAssets() []string {
	return this.RuntimeAssets
}

func (this *Check) GetSubscriptions() []string {
	return this.Subscriptions
}

func (this *Check) GetProxyEntityName() string {
	return this.ProxyEntityName
}

func (this *Check) GetCheckHooks() []HookList {
	return this.CheckHooks
}

func (this *Check) GetStdin() bool {
	return this.Stdin
}

func (this *Check) GetSubdue() *TimeWindowWhen {
	return this.Subdue
}

func (this *Check) GetCron() string {
	return this.Cron
}

func (this *Check) GetTtl() int64 {
	return this.Ttl
}

func (this *Check) GetTimeout() uint32 {
	return this.Timeout
}

func (this *Check) GetProxyRequests() *ProxyRequests {
	return this.ProxyRequests
}

func (this *Check) GetRoundRobin() bool {
	return this.RoundRobin
}

func (this *Check) GetDuration() float64 {
	return this.Duration
}

func (this *Check) GetExecuted() int64 {
	return this.Executed
}

func (this *Check) GetHistory() []CheckHistory {
	return this.History
}

func (this *Check) GetIssued() int64 {
	return this.Issued
}

func (this *Check) GetOutput() string {
	return this.Output
}

func (this *Check) GetState() string {
	return this.State
}

func (this *Check) GetStatus() uint32 {
	return this.Status
}

func (this *Check) GetTotalStateChange() uint32 {
	return this.TotalStateChange
}

func (this *Check) GetLastOK() int64 {
	return this.LastOK
}

func (this *Check) GetOccurrences() int64 {
	return this.Occurrences
}

func (this *Check) GetOccurrencesWatermark() int64 {
	return this.OccurrencesWatermark
}

func (this *Check) GetSilenced() []string {
	return this.Silenced
}

func (this *Check) GetHooks() []*Hook {
	return this.Hooks
}

func (this *Check) GetOutputMetricFormat() string {
	return this.OutputMetricFormat
}

func (this *Check) GetOutputMetricHandlers() []string {
	return this.OutputMetricHandlers
}

func (this *Check) GetEnvVars() []string {
	return this.EnvVars
}

func (this *Check) GetObjectMeta() ObjectMeta {
	return this.ObjectMeta
}

func (this *Check) GetMaxOutputSize() int64 {
	return this.MaxOutputSize
}

func (this *Check) GetDiscardOutput() bool {
	return this.DiscardOutput
}

func (this *Check) GetGroupBy() *CheckKey {
	return this.GroupBy
}

func (this *Check) GetExtendedAttributes() []byte {
	return this.ExtendedAttributes
}

func NewCheckFromFace(that CheckFace) *Check {
	this := &Check{}
	this.Command = that.GetCommand()
	this.Handlers = that.GetHandlers()
	this.HighFlapThreshold = that.GetHighFlapThreshold()
	this.Interval = that.GetInterval()
	this.LowFlapThreshold = that.GetLowFlapThreshold()
	this.Publish = that.GetPublish()
	this.RuntimeAssets = that.GetRuntimeAssets()
	this.Subscriptions = that.GetSubscriptions()
	this.ProxyEntityName = that.GetProxyEntityName()
	this.CheckHooks = that.GetCheckHooks()
	this.Stdin = that.GetStdin()
	this.Subdue = that.GetSubdue()
	this.Cron = that.GetCron()
	this.Ttl = that.GetTtl()
	this.Timeout = that.GetTimeout()
	this.ProxyRequests = that.GetProxyRequests()
	this.RoundRobin = that.GetRoundRobin()
	this.Duration = that.GetDuration()
	this.Executed = that.GetExecuted()
	this.History = that.GetHistory()
	this.Issued = that.GetIssued()
	this.Output = that.GetOutput()
	this.State = that.GetState()
	this.Status = that.GetStatus()
	this.TotalStateChange = that.GetTotalStateChange()
	this.LastOK = that.GetLastOK()
	this.Occurrences = that.GetOccurrences()
	this.OccurrencesWatermark = that.GetOccurrencesWatermark()
	this.Silenced = that.GetSilenced()
	this.Hooks = that.GetHooks()
	this.OutputMetricFormat = that.GetOutputMetricFormat()
	this.OutputMetricHandlers = that.GetOutputMetricHandlers()
	this.EnvVars = that.GetEnvVars()
	this.ObjectMeta = that.GetObjectMeta()
	this.MaxOutputSize = that.GetMaxOutputSize()
	this.DiscardOutput = that.GetDiscardOutput()
	this.GroupBy = that.GetGroupBy()
	this.ExtendedAttributes = that.GetExtendedAttributes()
	return this
}

func (m *CheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Config.Size()))
		n1, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Assets) > 0 {
		for _, msg := range m.Assets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hooks) > 0 {
		for _, msg := range m.Hooks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Issued != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Issued))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyRequests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EntityAttributes) > 0 {
		for _, s := range m.EntityAttributes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Splay {
		dAtA[i] = 0x10
		i++
		if m.Splay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SplayCoverage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.SplayCoverage))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HighFlapThreshold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.LowFlapThreshold))
	}
	if m.Publish {
		dAtA[i] = 0x48
		i++
		if m.Publish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtendedAttributes) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ExtendedAttributes)))
		i += copy(dAtA[i:], m.ExtendedAttributes)
	}
	if len(m.ProxyEntityName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ProxyEntityName)))
		i += copy(dAtA[i:], m.ProxyEntityName)
	}
	if len(m.CheckHooks) > 0 {
		for _, msg := range m.CheckHooks {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Stdin {
		dAtA[i] = 0x78
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Subdue != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Subdue.Size()))
		n2, err := m.Subdue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Cron) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Cron)))
		i += copy(dAtA[i:], m.Cron)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.ProxyRequests.Size()))
		n3, err := m.ProxyRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.RoundRobin {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.RoundRobin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.OutputMetricFormat) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.OutputMetricFormat)))
		i += copy(dAtA[i:], m.OutputMetricFormat)
	}
	if len(m.OutputMetricHandlers) > 0 {
		for _, s := range m.OutputMetricHandlers {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EnvVars) > 0 {
		for _, s := range m.EnvVars {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0xd2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCheck(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.MaxOutputSize != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.MaxOutputSize))
	}
	if m.DiscardOutput {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if m.DiscardOutput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupBy != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.GroupBy.Size()))
		n5, err := m.GroupBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HighFlapThreshold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.LowFlapThreshold))
	}
	if m.Publish {
		dAtA[i] = 0x48
		i++
		if m.Publish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProxyEntityName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ProxyEntityName)))
		i += copy(dAtA[i:], m.ProxyEntityName)
	}
	if len(m.CheckHooks) > 0 {
		for _, msg := range m.CheckHooks {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Stdin {
		dAtA[i] = 0x78
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Subdue != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Subdue.Size()))
		n6, err := m.Subdue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Cron) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Cron)))
		i += copy(dAtA[i:], m.Cron)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.ProxyRequests.Size()))
		n7, err := m.ProxyRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.RoundRobin {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.RoundRobin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Duration != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Duration))))
		i += 8
	}
	if m.Executed != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Executed))
	}
	if len(m.History) > 0 {
		for _, msg := range m.History {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Issued != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Issued))
	}
	if len(m.Output) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.Output)))
		i += copy(dAtA[i:], m.Output)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Status != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Status))
	}
	if m.TotalStateChange != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.TotalStateChange))
	}
	if m.LastOK != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.LastOK))
	}
	if m.Occurrences != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Occurrences))
	}
	if m.OccurrencesWatermark != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.OccurrencesWatermark))
	}
	if len(m.Silenced) > 0 {
		for _, s := range m.Silenced {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Hooks) > 0 {
		for _, msg := range m.Hooks {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputMetricFormat) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.OutputMetricFormat)))
		i += copy(dAtA[i:], m.OutputMetricFormat)
	}
	if len(m.OutputMetricHandlers) > 0 {
		for _, s := range m.OutputMetricHandlers {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EnvVars) > 0 {
		for _, s := range m.EnvVars {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintCheck(dAtA, i, uint64(m.ObjectMeta.Size()))
	n8, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.MaxOutputSize != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.MaxOutputSize))
	}
	if m.DiscardOutput {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.DiscardOutput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupBy != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.GroupBy.Size()))
		n9, err := m.GroupBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.ExtendedAttributes) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCheck(dAtA, i, uint64(len(m.ExtendedAttributes)))
		i += copy(dAtA[i:], m.ExtendedAttributes)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Status))
	}
	if m.Executed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCheck(dAtA, i, uint64(m.Executed))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name {
		dAtA[i] = 0x8
		i++
		if m.Name {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Hostname {
		dAtA[i] = 0x10
		i++
		if m.Hostname {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CheckLabels) > 0 {
		for _, s := range m.CheckLabels {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EntityLabels) > 0 {
		for _, s := range m.EntityLabels {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EventLabels) > 0 {
		for _, s := range m.EventLabels {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCheck(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedCheckRequest(r randyCheck, easy bool) *CheckRequest {
	this := &CheckRequest{}
	if r.Intn(10) != 0 {
		this.Config = NewPopulatedCheckConfig(r, easy)
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Assets = make([]Asset, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedAsset(r, easy)
			this.Assets[i] = *v2
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Hooks = make([]HookConfig, v3)
		for i := 0; i < v3; i++ {
			v4 := NewPopulatedHookConfig(r, easy)
			this.Hooks[i] = *v4
		}
	}
	this.Issued = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Issued *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedCheck(r, 5)
	}
	return this
}

func NewPopulatedProxyRequests(r randyCheck, easy bool) *ProxyRequests {
	this := &ProxyRequests{}
	v5 := r.Intn(10)
	this.EntityAttributes = make([]string, v5)
	for i := 0; i < v5; i++ {
		this.EntityAttributes[i] = string(randStringCheck(r))
	}
	this.Splay = bool(bool(r.Intn(2) == 0))
	this.SplayCoverage = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedCheck(r, 4)
	}
	return this
}

func NewPopulatedCheckConfig(r randyCheck, easy bool) *CheckConfig {
	this := &CheckConfig{}
	this.Command = string(randStringCheck(r))
	v6 := r.Intn(10)
	this.Handlers = make([]string, v6)
	for i := 0; i < v6; i++ {
		this.Handlers[i] = string(randStringCheck(r))
	}
	this.HighFlapThreshold = uint32(r.Uint32())
	this.Interval = uint32(r.Uint32())
	this.LowFlapThreshold = uint32(r.Uint32())
	this.Publish = bool(bool(r.Intn(2) == 0))
	v7 := r.Intn(10)
	this.RuntimeAssets = make([]string, v7)
	for i := 0; i < v7; i++ {
		this.RuntimeAssets[i] = string(randStringCheck(r))
	}
	v8 := r.Intn(10)
	this.Subscriptions = make([]string, v8)
	for i := 0; i < v8; i++ {
		this.Subscriptions[i] = string(randStringCheck(r))
	}
	v9 := r.Intn(100)
	this.ExtendedAttributes = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.ExtendedAttributes[i] = byte(r.Intn(256))
	}
	this.ProxyEntityName = string(randStringCheck(r))
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.CheckHooks = make([]HookList, v10)
		for i := 0; i < v10; i++ {
			v11 := NewPopulatedHookList(r, easy)
			this.CheckHooks[i] = *v11
		}
	}
	this.Stdin = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.Subdue = NewPopulatedTimeWindowWhen(r, easy)
	}
	this.Cron = string(randStringCheck(r))
	this.Ttl = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Ttl *= -1
	}
	this.Timeout = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.ProxyRequests = NewPopulatedProxyRequests(r, easy)
	}
	this.RoundRobin = bool(bool(r.Intn(2) == 0))
	this.OutputMetricFormat = string(randStringCheck(r))
	v12 := r.Intn(10)
	this.OutputMetricHandlers = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.OutputMetricHandlers[i] = string(randStringCheck(r))
	}
	v13 := r.Intn(10)
	this.EnvVars = make([]string, v13)
	for i := 0; i < v13; i++ {
		this.EnvVars[i] = string(randStringCheck(r))
	}
	v14 := NewPopulatedObjectMeta(r, easy)
	this.ObjectMeta = *v14
	this.MaxOutputSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.MaxOutputSize *= -1
	}
	this.DiscardOutput = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.GroupBy = NewPopulatedCheckKey(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedCheck(r, 30)
	}
	return this
}

func NewPopulatedCheck(r randyCheck, easy bool) *Check {
	this := &Check{}
	this.Command = string(randStringCheck(r))
	v15 := r.Intn(10)
	this.Handlers = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.Handlers[i] = string(randStringCheck(r))
	}
	this.HighFlapThreshold = uint32(r.Uint32())
	this.Interval = uint32(r.Uint32())
	this.LowFlapThreshold = uint32(r.Uint32())
	this.Publish = bool(bool(r.Intn(2) == 0))
	v16 := r.Intn(10)
	this.RuntimeAssets = make([]string, v16)
	for i := 0; i < v16; i++ {
		this.RuntimeAssets[i] = string(randStringCheck(r))
	}
	v17 := r.Intn(10)
	this.Subscriptions = make([]string, v17)
	for i := 0; i < v17; i++ {
		this.Subscriptions[i] = string(randStringCheck(r))
	}
	this.ProxyEntityName = string(randStringCheck(r))
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.CheckHooks = make([]HookList, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedHookList(r, easy)
			this.CheckHooks[i] = *v19
		}
	}
	this.Stdin = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.Subdue = NewPopulatedTimeWindowWhen(r, easy)
	}
	this.Cron = string(randStringCheck(r))
	this.Ttl = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Ttl *= -1
	}
	this.Timeout = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.ProxyRequests = NewPopulatedProxyRequests(r, easy)
	}
	this.RoundRobin = bool(bool(r.Intn(2) == 0))
	this.Duration = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Duration *= -1
	}
	this.Executed = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Executed *= -1
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.History = make([]CheckHistory, v20)
		for i := 0; i < v20; i++ {
			v21 := NewPopulatedCheckHistory(r, easy)
			this.History[i] = *v21
		}
	}
	this.Issued = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Issued *= -1
	}
	this.Output = string(randStringCheck(r))
	this.State = string(randStringCheck(r))
	this.Status = uint32(r.Uint32())
	this.TotalStateChange = uint32(r.Uint32())
	this.LastOK = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastOK *= -1
	}
	this.Occurrences = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Occurrences *= -1
	}
	this.OccurrencesWatermark = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.OccurrencesWatermark *= -1
	}
	v22 := r.Intn(10)
	this.Silenced = make([]string, v22)
	for i := 0; i < v22; i++ {
		this.Silenced[i] = string(randStringCheck(r))
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.Hooks = make([]*Hook, v23)
		for i := 0; i < v23; i++ {
			this.Hooks[i] = NewPopulatedHook(r, easy)
		}
	}
	this.OutputMetricFormat = string(randStringCheck(r))
	v24 := r.Intn(10)
	this.OutputMetricHandlers = make([]string, v24)
	for i := 0; i < v24; i++ {
		this.OutputMetricHandlers[i] = string(randStringCheck(r))
	}
	v25 := r.Intn(10)
	this.EnvVars = make([]string, v25)
	for i := 0; i < v25; i++ {
		this.EnvVars[i] = string(randStringCheck(r))
	}
	v26 := NewPopulatedObjectMeta(r, easy)
	this.ObjectMeta = *v26
	this.MaxOutputSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.MaxOutputSize *= -1
	}
	this.DiscardOutput = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.GroupBy = NewPopulatedCheckKey(r, easy)
	}
	v27 := r.Intn(100)
	this.ExtendedAttributes = make([]byte, v27)
	for i := 0; i < v27; i++ {
		this.ExtendedAttributes[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedCheck(r, 100)
	}
	return this
}

func NewPopulatedCheckHistory(r randyCheck, easy bool) *CheckHistory {
	this := &CheckHistory{}
	this.Status = uint32(r.Uint32())
	this.Executed = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Executed *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedCheck(r, 3)
	}
	return this
}

func NewPopulatedCheckKey(r randyCheck, easy bool) *CheckKey {
	this := &CheckKey{}
	this.Name = bool(bool(r.Intn(2) == 0))
	this.Hostname = bool(bool(r.Intn(2) == 0))
	v28 := r.Intn(10)
	this.CheckLabels = make([]string, v28)
	for i := 0; i < v28; i++ {
		this.CheckLabels[i] = string(randStringCheck(r))
	}
	v29 := r.Intn(10)
	this.EntityLabels = make([]string, v29)
	for i := 0; i < v29; i++ {
		this.EntityLabels[i] = string(randStringCheck(r))
	}
	v30 := r.Intn(10)
	this.EventLabels = make([]string, v30)
	for i := 0; i < v30; i++ {
		this.EventLabels[i] = string(randStringCheck(r))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedCheck(r, 6)
	}
	return this
}

type randyCheck interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneCheck(r randyCheck) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringCheck(r randyCheck) string {
	v31 := r.Intn(100)
	tmps := make([]rune, v31)
	for i := 0; i < v31; i++ {
		tmps[i] = randUTF8RuneCheck(r)
	}
	return string(tmps)
}
func randUnrecognizedCheck(r randyCheck, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldCheck(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldCheck(dAtA []byte, r randyCheck, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		v32 := r.Int63()
		if r.Intn(2) == 0 {
			v32 *= -1
		}
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(v32))
	case 1:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateCheck(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateCheck(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *CheckRequest) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Hooks) > 0 {
		for _, e := range m.Hooks {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Issued != 0 {
		n += 1 + sovCheck(uint64(m.Issued))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyRequests) Size() (n int) {
	var l int
	_ = l
	if len(m.EntityAttributes) > 0 {
		for _, s := range m.EntityAttributes {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Splay {
		n += 2
	}
	if m.SplayCoverage != 0 {
		n += 1 + sovCheck(uint64(m.SplayCoverage))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.HighFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		n += 1 + sovCheck(uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.LowFlapThreshold))
	}
	if m.Publish {
		n += 2
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.ExtendedAttributes)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	l = len(m.ProxyEntityName)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.CheckHooks) > 0 {
		for _, e := range m.CheckHooks {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Stdin {
		n += 2
	}
	if m.Subdue != nil {
		l = m.Subdue.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.Cron)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.Ttl != 0 {
		n += 2 + sovCheck(uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		n += 2 + sovCheck(uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		l = m.ProxyRequests.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.RoundRobin {
		n += 3
	}
	l = len(m.OutputMetricFormat)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if len(m.OutputMetricHandlers) > 0 {
		for _, s := range m.OutputMetricHandlers {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	if len(m.EnvVars) > 0 {
		for _, s := range m.EnvVars {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	l = m.ObjectMeta.Size()
	n += 2 + l + sovCheck(uint64(l))
	if m.MaxOutputSize != 0 {
		n += 2 + sovCheck(uint64(m.MaxOutputSize))
	}
	if m.DiscardOutput {
		n += 3
	}
	if m.GroupBy != nil {
		l = m.GroupBy.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Check) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.Handlers) > 0 {
		for _, s := range m.Handlers {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.HighFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.HighFlapThreshold))
	}
	if m.Interval != 0 {
		n += 1 + sovCheck(uint64(m.Interval))
	}
	if m.LowFlapThreshold != 0 {
		n += 1 + sovCheck(uint64(m.LowFlapThreshold))
	}
	if m.Publish {
		n += 2
	}
	if len(m.RuntimeAssets) > 0 {
		for _, s := range m.RuntimeAssets {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.ProxyEntityName)
	if l > 0 {
		n += 1 + l + sovCheck(uint64(l))
	}
	if len(m.CheckHooks) > 0 {
		for _, e := range m.CheckHooks {
			l = e.Size()
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.Stdin {
		n += 2
	}
	if m.Subdue != nil {
		l = m.Subdue.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.Cron)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.Ttl != 0 {
		n += 2 + sovCheck(uint64(m.Ttl))
	}
	if m.Timeout != 0 {
		n += 2 + sovCheck(uint64(m.Timeout))
	}
	if m.ProxyRequests != nil {
		l = m.ProxyRequests.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.RoundRobin {
		n += 3
	}
	if m.Duration != 0 {
		n += 10
	}
	if m.Executed != 0 {
		n += 2 + sovCheck(uint64(m.Executed))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	if m.Issued != 0 {
		n += 2 + sovCheck(uint64(m.Issued))
	}
	l = len(m.Output)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovCheck(uint64(m.Status))
	}
	if m.TotalStateChange != 0 {
		n += 2 + sovCheck(uint64(m.TotalStateChange))
	}
	if m.LastOK != 0 {
		n += 2 + sovCheck(uint64(m.LastOK))
	}
	if m.Occurrences != 0 {
		n += 2 + sovCheck(uint64(m.Occurrences))
	}
	if m.OccurrencesWatermark != 0 {
		n += 2 + sovCheck(uint64(m.OccurrencesWatermark))
	}
	if len(m.Silenced) > 0 {
		for _, s := range m.Silenced {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	if len(m.Hooks) > 0 {
		for _, e := range m.Hooks {
			l = e.Size()
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	l = len(m.OutputMetricFormat)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if len(m.OutputMetricHandlers) > 0 {
		for _, s := range m.OutputMetricHandlers {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	if len(m.EnvVars) > 0 {
		for _, s := range m.EnvVars {
			l = len(s)
			n += 2 + l + sovCheck(uint64(l))
		}
	}
	l = m.ObjectMeta.Size()
	n += 2 + l + sovCheck(uint64(l))
	if m.MaxOutputSize != 0 {
		n += 2 + sovCheck(uint64(m.MaxOutputSize))
	}
	if m.DiscardOutput {
		n += 3
	}
	if m.GroupBy != nil {
		l = m.GroupBy.Size()
		n += 2 + l + sovCheck(uint64(l))
	}
	l = len(m.ExtendedAttributes)
	if l > 0 {
		n += 2 + l + sovCheck(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckHistory) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCheck(uint64(m.Status))
	}
	if m.Executed != 0 {
		n += 1 + sovCheck(uint64(m.Executed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name {
		n += 2
	}
	if m.Hostname {
		n += 2
	}
	if len(m.CheckLabels) > 0 {
		for _, s := range m.CheckLabels {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.EntityLabels) > 0 {
		for _, s := range m.EntityLabels {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if len(m.EventLabels) > 0 {
		for _, s := range m.EventLabels {
			l = len(s)
			n += 1 + l + sovCheck(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCheck(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCheck(x uint64) (n int) {
	return sovCheck(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &CheckConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hooks = append(m.Hooks, HookConfig{})
			if err := m.Hooks[len(m.Hooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			m.Issued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Issued |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyRequests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyRequests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityAttributes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityAttributes = append(m.EntityAttributes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Splay = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplayCoverage", wireType)
			}
			m.SplayCoverage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplayCoverage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handlers = append(m.Handlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighFlapThreshold", wireType)
			}
			m.HighFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowFlapThreshold", wireType)
			}
			m.LowFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeAssets = append(m.RuntimeAssets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedAttributes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedAttributes = append(m.ExtendedAttributes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtendedAttributes == nil {
				m.ExtendedAttributes = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEntityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyEntityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckHooks = append(m.CheckHooks, HookList{})
			if err := m.CheckHooks[len(m.CheckHooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subdue == nil {
				m.Subdue = &TimeWindowWhen{}
			}
			if err := m.Subdue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyRequests == nil {
				m.ProxyRequests = &ProxyRequests{}
			}
			if err := m.ProxyRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundRobin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundRobin = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMetricFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputMetricFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMetricHandlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputMetricHandlers = append(m.OutputMetricHandlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvVars = append(m.EnvVars, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOutputSize", wireType)
			}
			m.MaxOutputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOutputSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscardOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiscardOutput = bool(v != 0)
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupBy == nil {
				m.GroupBy = &CheckKey{}
			}
			if err := m.GroupBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handlers = append(m.Handlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighFlapThreshold", wireType)
			}
			m.HighFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowFlapThreshold", wireType)
			}
			m.LowFlapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowFlapThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeAssets = append(m.RuntimeAssets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEntityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyEntityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckHooks = append(m.CheckHooks, HookList{})
			if err := m.CheckHooks[len(m.CheckHooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subdue == nil {
				m.Subdue = &TimeWindowWhen{}
			}
			if err := m.Subdue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyRequests == nil {
				m.ProxyRequests = &ProxyRequests{}
			}
			if err := m.ProxyRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundRobin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundRobin = bool(v != 0)
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Duration = float64(math.Float64frombits(v))
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			m.Executed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Executed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, CheckHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			m.Issued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Issued |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStateChange", wireType)
			}
			m.TotalStateChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalStateChange |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOK", wireType)
			}
			m.LastOK = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOK |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrences", wireType)
			}
			m.Occurrences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Occurrences |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OccurrencesWatermark", wireType)
			}
			m.OccurrencesWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OccurrencesWatermark |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silenced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Silenced = append(m.Silenced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hooks = append(m.Hooks, &Hook{})
			if err := m.Hooks[len(m.Hooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMetricFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputMetricFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMetricHandlers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputMetricHandlers = append(m.OutputMetricHandlers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvVars = append(m.EnvVars, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOutputSize", wireType)
			}
			m.MaxOutputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOutputSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscardOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiscardOutput = bool(v != 0)
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupBy == nil {
				m.GroupBy = &CheckKey{}
			}
			if err := m.GroupBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedAttributes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedAttributes = append(m.ExtendedAttributes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtendedAttributes == nil {
				m.ExtendedAttributes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			m.Executed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Executed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Name = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hostname = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckLabels = append(m.CheckLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityLabels = append(m.EntityLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventLabels = append(m.EventLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCheck(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCheck
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCheck
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCheck
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCheck(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCheck = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCheck   = fmt.Errorf("proto: integer overflow")
)
